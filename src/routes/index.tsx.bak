import { useState, useEffect, useRef } from 'react';
import { createFileRoute } from "@tanstack/react-router";
import { toast } from 'sonner';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { WalletConnect } from '@/components/WalletConnect';
import { BalanceDisplay } from '@/components/BalanceDisplay';
import { DiceGame } from '@/components/DiceGame';
import { GameHistory } from '@/components/GameHistory';
import { GameStats } from '@/components/GameStats';
import { AutoBet, type AutoBetConfig } from '@/components/AutoBet';
import { FairnessVerification } from '@/components/FairnessVerification';
import { DepositDialog } from '@/components/DepositDialog';
import { useWallet, useWalletBalances, useUserWallets, useDeposit } from '@/hooks/useWallet';
import { usePlaceBet, useGameSessions, useInitializeSeeds, useSessionForVerification } from '@/hooks/useGame';
import { createConfetti } from '@/lib/confetti';
import { Dice1, History, Shield, BarChart3, Zap } from 'lucide-react';

export const Route = createFileRoute("/")({
	component: App,
});

function App() {
	const { connectedAddress, currentUser, isConnected, connectWallet, disconnectWallet } = useWallet();
	const [selectedCurrency, setSelectedCurrency] = useState('ETH');
	const [depositDialogOpen, setDepositDialogOpen] = useState(false);
	const [selectedSessionId, setSelectedSessionId] = useState<string | null>(null);
	const [activeTab, setActiveTab] = useState('game');
	const [isAutoBetting, setIsAutoBetting] = useState(false);
	const [autoBetConfig, setAutoBetConfig] = useState<AutoBetConfig | null>(null);
	const [autoBetCount, setAutoBetCount] = useState(0);
	const autoBetTimeoutRef = useRef<NodeJS.Timeout | null>(null);
	const previousSessionCountRef = useRef<number>(0);

	// Queries
	const { data: wallets = [] } = useUserWallets(currentUser?.id || null);
	const { data: currentWallet } = useWalletBalances(currentUser?.id || null, selectedCurrency);
	const { data: gameSessions = [] } = useGameSessions(currentUser?.id || null);
	const { data: verificationData } = useSessionForVerification(selectedSessionId);

	// Mutations
	const placeBetMutation = usePlaceBet();
	const depositMutation = useDeposit();
	const initSeedsMutation = useInitializeSeeds();

	// Initialize server seeds on mount
	useEffect(() => {
		if (isConnected && currentUser) {
			initSeedsMutation.mutate();
		}
	}, [isConnected, currentUser]);

	// Track session changes for notifications
	useEffect(() => {
		if (gameSessions.length > previousSessionCountRef.current && previousSessionCountRef.current > 0) {
			const latestSession = gameSessions[0];
			const isWin = latestSession.status === 2; // WON
			const amount = parseFloat(latestSession.win_amount || '0');

			if (isWin && amount > 0) {
				toast.success('You Won!', {
					description: `+${amount.toFixed(8)} ${selectedCurrency}`,
					duration: 3000,
				});
				createConfetti();
			} else {
				toast.error('You Lost', {
					description: `Better luck next time!`,
					duration: 2000,
				});
			}
		}
		previousSessionCountRef.current = gameSessions.length;
	}, [gameSessions, selectedCurrency]);

	const handlePlaceBet = async (betAmount: string, target: number) => {
		if (!currentUser) {
			toast.error('Wallet not connected', { description: 'Please connect your wallet first' });
			return;
		}

		// Validate bet amount
		const betAmountNum = parseFloat(betAmount);
		if (betAmountNum <= 0 || isNaN(betAmountNum)) {
			toast.error('Invalid bet amount', { description: 'Please enter a valid bet amount' });
			return;
		}

		// Check balance
		const balance = parseFloat(currentWallet?.available_balance || '0');
		if (betAmountNum > balance) {
			toast.error('Insufficient balance', {
				description: `Available: ${balance.toFixed(8)} ${selectedCurrency}`
			});
			return;
		}

		// Generate random client seed
		const clientSeed = Math.random().toString(36).substring(2, 15);

		try {
			await placeBetMutation.mutateAsync({
				userId: currentUser.id,
				betAmount,
				currency: selectedCurrency,
				clientSeed,
				target,
			});
		} catch (error) {
			console.error('Failed to place bet:', error);
			const errorMessage = error instanceof Error ? error.message : 'Failed to place bet. Please try again.';
			toast.error('Bet failed', { description: errorMessage });
		}
	};

	const handleDeposit = async (amount: string) => {
		if (!currentUser) return;

		try {
			await depositMutation.mutateAsync({
				userId: currentUser.id,
				currency: selectedCurrency,
				amount,
			});
			setDepositDialogOpen(false);
			toast.success('Deposit successful', {
				description: `Added ${amount} ${selectedCurrency} to your balance`
			});
		} catch (error) {
			console.error('Failed to deposit:', error);
			toast.error('Deposit failed', { description: 'Please try again.' });
		}
	};

	const handleStartAutoBet = (config: AutoBetConfig) => {
		setAutoBetConfig(config);
		setIsAutoBetting(true);
		setAutoBetCount(0);
		toast.info('Auto-bet started', {
			description: `Running ${config.numberOfBets} bets`
		});
	};

	const handleStopAutoBet = () => {
		setIsAutoBetting(false);
		setAutoBetConfig(null);
		if (autoBetTimeoutRef.current) {
			clearTimeout(autoBetTimeoutRef.current);
		}
		toast.info('Auto-bet stopped', {
			description: `Completed ${autoBetCount} bets`
		});
	};

	// Auto-bet logic
	useEffect(() => {
		if (!isAutoBetting || !autoBetConfig) return;

		// Check if we should continue
		if (autoBetCount >= autoBetConfig.numberOfBets) {
			handleStopAutoBet();
			return;
		}

		// Check stop conditions
		if (gameSessions.length > 0 && autoBetCount > 0) {
			const lastSession = gameSessions[0];
			const isWin = lastSession.status === 2;
			const winAmount = parseFloat(lastSession.win_amount || '0');
			const betAmount = parseFloat(lastSession.bet_amount || '0');
			const profit = winAmount - betAmount;

			if (autoBetConfig.stopOnWin && isWin) {
				if (!autoBetConfig.stopOnWinAmount || winAmount >= autoBetConfig.stopOnWinAmount) {
					handleStopAutoBet();
					return;
				}
			}

			if (autoBetConfig.stopOnLoss && !isWin) {
				if (!autoBetConfig.stopOnLossAmount || Math.abs(profit) >= autoBetConfig.stopOnLossAmount) {
					handleStopAutoBet();
					return;
				}
			}
		}

		// Execute next bet
		autoBetTimeoutRef.current = setTimeout(() => {
			// This will be triggered by DiceGame component
			setAutoBetCount(prev => prev + 1);
		}, 1000);

		return () => {
			if (autoBetTimeoutRef.current) {
				clearTimeout(autoBetTimeoutRef.current);
			}
		};
	}, [isAutoBetting, autoBetConfig, autoBetCount, gameSessions]);

	const handleVerifySession = (sessionId: string) => {
		setSelectedSessionId(sessionId);
		setActiveTab('verify');
	};

	const lastSession = gameSessions[0];

	return (
		<div className="min-h-screen bg-background">
			<div className="container mx-auto p-6 max-w-7xl">
				{/* Header */}
				<div className="mb-8">
					<div className="flex items-center gap-3 mb-2">
						<Dice1 className="w-8 h-8 text-primary" />
						<h1 className="text-3xl font-bold">Provably Fair Dice</h1>
					</div>
					<p className="text-muted-foreground">
						Transparent, verifiable, blockchain-powered gaming
					</p>
				</div>

				{/* Wallet Connection */}
				<div className="mb-6">
					<WalletConnect
						isConnected={isConnected}
						connectedAddress={connectedAddress}
						onConnect={connectWallet}
						onDisconnect={disconnectWallet}
					/>
				</div>

				{!isConnected ? (
					<div className="text-center py-12">
						<Dice1 className="w-16 h-16 mx-auto mb-4 text-muted-foreground opacity-50" />
						<p className="text-xl text-muted-foreground mb-2">
							Connect your wallet to start playing
						</p>
						<p className="text-sm text-muted-foreground">
							Experience provably fair gaming with cryptographic verification
						</p>
					</div>
				) : (
					<>
						{/* Balance */}
						<div className="mb-6">
							<BalanceDisplay
								wallets={wallets}
								selectedCurrency={selectedCurrency}
								onCurrencyChange={setSelectedCurrency}
								onDeposit={() => setDepositDialogOpen(true)}
							/>
						</div>

						{/* Main Content */}
						<Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-6">
							<TabsList className="grid w-full grid-cols-3">
								<TabsTrigger value="game">
									<Dice1 className="w-4 h-4 mr-2" />
									Play
								</TabsTrigger>
								<TabsTrigger value="history">
									<History className="w-4 h-4 mr-2" />
									History
								</TabsTrigger>
								<TabsTrigger value="verify">
									<Shield className="w-4 h-4 mr-2" />
									Verify
								</TabsTrigger>
							</TabsList>

							<TabsContent value="game">
								<DiceGame
									onPlaceBet={handlePlaceBet}
									isPlaying={placeBetMutation.isPending}
									currentBalance={parseFloat(currentWallet?.available_balance || '0')}
									lastOutcome={lastSession?.outcome}
									lastWon={lastSession?.status === 2}
								/>
							</TabsContent>

							<TabsContent value="history">
								<GameHistory
									sessions={gameSessions}
									onVerify={handleVerifySession}
								/>
							</TabsContent>

							<TabsContent value="verify">
								<FairnessVerification
									sessionId={selectedSessionId || undefined}
									serverSeed={verificationData?.serverSeed.seed_value}
									clientSeed={verificationData?.session.client_seed}
									nonce={verificationData?.session.nonce}
									expectedOutcome={verificationData?.session.outcome || undefined}
								/>
							</TabsContent>
						</Tabs>
					</>
				)}

				{/* Deposit Dialog */}
				<DepositDialog
					open={depositDialogOpen}
					onOpenChange={setDepositDialogOpen}
					currency={selectedCurrency}
					onDeposit={handleDeposit}
					isDepositing={depositMutation.isPending}
				/>
			</div>
		</div>
	);
}
